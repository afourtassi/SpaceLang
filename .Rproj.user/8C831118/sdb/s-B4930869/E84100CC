{
    "collab_server" : "",
    "contents" : "var Id = function(position, rotation){\n  return {x:position.x, y:position.y};\n};\n\n//this reflection is for front/back\nvar Ref = function(position, rotation){\n  return {x:-position.x, y:-position.y};\n};\n\n//define rotation in general\n////////////////////////////\n\nvar Rot = function(position, rotation){\n  var theta = rotation\n  var theta_rad = theta * Math.PI * 1/180\n  var rot_x= position.x*Math.cos(theta_rad)-position.y*Math.sin(theta_rad);\n  var rot_y= position.x*Math.sin(theta_rad)+position.y*Math.cos(theta_rad);\n\n  return {x:Math.round(rot_x), y:Math.round(rot_y)};\n};\n\n//define rotation for side (left-right)\nvar Rot_side = function(position, rotation){\n  return Rot(position, 90)\n}\n\n//This rotation is for non-egocentric frame of reference \nvar Rot_allo = function(position, rotation){\n  return Rot(position, rotation)\n}\n\n//define composition \nvar Comp = function (opr1, opr2){\n  return function (position, rotation){\n    opr1(opr2(position, rotation),rotation)\n  }\n}\n\n//So we are learning 4 words: both front/back, left/right, and we have 8 hypotheses\n\nvar hyp_space = [ {name:'id', operation:Id, len:1}, // front\n                  {name:'ref', operation:Ref, len:1}, // back\n                 \n                  {name:'rotSide_id', operation:Comp(Rot_side,Id), len:2}, //left ego\n                  {name:'rotSide_ref', operation:Comp(Rot_side,Ref), len:2}, // right ego\n                 \n                  {name:'rotFrame_id', operation:Comp(Rot_allo,Id), len:2}, //front allo\n                  {name:'rotFrame_ref', operation:Comp(Rot_allo,Ref), len:2}, // right allo\n                 \n                  {name:'rotFrame_Side_id', operation:Comp(Rot_allo, Comp(Rot_side, Id)), len:3}, //left allo\n                  {name:'rotFrame_Side_ref', operation:Comp(Rot_allo, Comp(Rot_side, Ref)), len:3} //right allo\n\n \n                ]\n\n\nvar hyp_names  =  map(function(hyp){\nreturn hyp.name\n}, hyp_space)\n\nvar positions = [\n                 {x:-1,y:0},\n                 {x:1, y:0},\n                 {x:0, y:1},\n                 {x:0, y:-1}\n                  ];\n\nvar utterances = ['left',\n                  'right',\n                  'front',\n                  'back'\n                 ];\n\nvar rotations = [0,\n                90,\n                180,\n                270];\n\nvar utterancePrior = Categorical({vs: utterances, ps: [1/4, 1/4, 1/4, 1/4]});\nvar positionPrior =  Categorical({vs: positions, ps: [1/4, 1/4, 1/4, 1/4]});\nvar rotationPrior =  Categorical({vs: rotations, ps: [1/4, 1/4, 1/4, 1/4]});\n\n//Every word (e.g., 'left' , 'right') has a probability distribution over all hypotheses \n// have a different prioir for each word and each hypothesis\n//let's first try different infernce for each word \n\nvar wordPrior = function(word) { \n    var hypProbs = T.toScalars(dirichlet(ones([hyp_names.length, 1])))\n    return Categorical({vs: hyp_names, ps: hypProbs})\n}\n\n\n//Egocentric Meaning: returns true if the word maps to the correct position  \nvar meaning = function(utt, position, rotation) {\n    var rot_position = Rot(position, -rotation)\n    return utt=='front'? (rot_position.x==0 && rot_position.y==1):\n    utt=='back'? (rot_position.x==0 && rot_position.y==-1):\n    utt=='left'? (rot_position.x==-1 && rot_position.y==0):\n    utt=='right'? (rot_position.x==1 && rot_position.y==0):\n    true\n};\n\n//Speaker: has in mind a position, and utter the corresponding word based on rotation \nvar S = cache(function(position, rotation) {\n  return Infer({method:'enumerate'}, function(){\n    var utt = sample(utterancePrior);\n    condition(meaning(utt, position, rotation));\n    return utt;\n  });\n});\n\n\nvar data = input  \n\nvar alpha=data[0].alpha\nvar beta=data[0].beta\nvar myWord = data[0].word \n\n//Listner: hears a word, sees a rotation and try to associate it with a meaning from the space\n\n//Do a conditional (if the word is the same )\nvar L1 = function(trueRotation, wordDist) {\n  return Infer({method:'enumerate'}, function(){\n    var rep = uniformDraw(hyp_space); //sample a representation\n    var rep_opr = rep.operation\n    var response =  rep_opr({x:0,y:1}, trueRotation) \n  \n    factor(alpha*wordDist.score(rep.name)-beta*rep.len)\n    //factor(-beta*rep.len)\n    //factor(alpha*wordDist.score(rep.name)+beta*rep.len)\n    return [response.x, response.y]\n  });\n};\n\n\n\nvar wordPost = function(word, data) {\n  return Infer({method : 'MCMC', samples : 10000, burn: 2000}, function() {\n    var wordDist = wordPrior(word);\n    mapData({data: data}, function(datum){\n      if (datum.word == word) {observe(L1(datum.rot, wordDist), [datum.x, datum.y])}\n    });\n    return wordDist;\n  });\n};\n\n\n//model()\nvar learnData = function(size) {\n  \n  var step = function(data) {\n    if(data.length == size) return data;\n    \n    var position = sample(positionPrior)\n    var rotation = sample(rotationPrior)\n    var utt = sample(S(position, rotation))\n    \n    var newDatum = {x: position.x, y: position.y, rot: rotation, word: utt}\n  \n  return  step(data.concat(newDatum));\n    \n  }\n  \n    step([]);\n}\n\n\nvar model =  function () {\n  var data = learnData(20)\n  var hyps = map(function(w){ \n      return wordPost(w, data).MAP().val;\n    }, utterances)\n  return _.object(utterances, hyps);\n};\n\n//var data = learnData(10)\n\nwordPost(myWord, data).MAP().val",
    "created" : 1522952476210.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2158289531",
    "id" : "E84100CC",
    "lastKnownWriteTime" : 1522951209,
    "last_content_update" : 1522951209,
    "path" : "~/Documents/Experiments/SpaceLang/models/model_4words.wppl",
    "project_path" : "models/model_4words.wppl",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "text"
}